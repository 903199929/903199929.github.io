# MySQL执行计划

执行计划就是SQL执行查询的顺序，以及如何使用索引查询，返回的结果集行数。

```SQL
EXPLAIN SELECT * FROM A WHERE X = ? AND Y = ?;
```

1. **id**: 是一个有顺序的编号，是查询的顺序号，有几个`SELECT`就显示几行。id的顺序是按`SELECT`出现的顺序增长的。id列的值越大执行优先级越高越先执行，id列的值相同则从上往下执行，id列的值为NULL最后执行。
2. **selectType**: 表示查询中每个`SELECT`子句的类型
   - SIMPLE: 表示此查询不包含`UNION`查询或子查询
   - PRIMARY: 表示此查询是最外层的查询（包含子查询）
   - SUBQUERY: 子查询中的第一个`SELECT`
   - UNION: 表示此查询是`UNION`的第二或随后的查询
   - DEPENDENT UNION:`UNION`中的第二个或后面的查询语句，取决于外面的查询
   - UNION RESULT: `UNION`的结果
   - DEPENDENT SUBQUERY: 子查询中的第一个`SELECT`，取决于外面的查询，即子查询依赖于外层查询的结果
   - DERIVED: 衍生，表示导出表的`SELECT`(FROM子句子查询)
3. **table**: 表示该语句查询的表
4. **type**: 优化SQL的重要字段，也是判断SQL性能和优化程度的重要指标。以下执行效率排序由高到低，最好避免`ALL`和`index`
   - const: 通过索引一次命中，匹配一行数据，例如`select * from table where id = 1;`。
   - system: 表中只有一行记录，相当于系统表。
   - eq_ref: 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。
   - ref: 非唯一性索引扫描，返回匹配某个值的所有。
   - range: 只检索给定范围的行，使用一个索引来选择行，一般用于`between`,`<`,`>`。
   - index: 只遍历索引树
   - ALL: 全表扫描，这个类型的查询是性能最差的查询之一，基本上随着表的数量增多，执行效率越慢。
5. **possible_keys**: 表示MySQL在执行SQL语句的时候，可能用到的索引信息，仅仅是可能不一定会用到。
6. **key**: MySQL在当前查询时所真正使用到的索引，是`possible_keys`的子集
7. **key_len**: 表示查询优化器使用了索引的字节数，这个字段可以评估组合索引是否完全被使用，这也是我们优化SQL时，评估索引的重要指标。
8. **rows**: MySQL查询优化器根据统计信息，估算该SQL返回结果集需要扫描读取的行数，这个值相当重要，索引优化以后，扫描读取的行数大说明索引设置不对，或者有字段传入的类型之类的问题，优化空间很大。
9. **filtered**:返回结果的行占所需要读到的行（rows列的值）的百分比，也就是百分比越高，说明需要查询到的数据越准确，百分比越小，说明查询到的数据量大，而结果集很少。
10. **extra**: 
    - using filesort: 表示MySQL对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有`using filesort`都建议优化掉，因为这样的查询对cpu资源消耗大，延时大。
    - using index: 覆盖索引扫描，表示查询在索引树中就可查找所需数据，不用扫描表数据文件，往往说明性能不错。
    - using temporary: 查询有使用临时表，一般出现于排序，分组和多表`join`的情况，查询效率不高，建议优化。
    - using where: SQL使用了`where`过滤，效率较高。